# authentication/adapters.py
import logging

from allauth.account.adapter import DefaultAccountAdapter
from allauth.socialaccount.adapter import DefaultSocialAccountAdapter
from django.conf import settings

logger = logging.getLogger(__name__)


class CustomSocialAccountAdapter(DefaultSocialAccountAdapter):
    """
    Custom adapter for social authentication
    Handles UUID-based User model properly
    """

    def pre_social_login(self, request, sociallogin):
        """
        Connect social account to existing user if email matches.
        Works reliably even when extra_data['email'] is None (common with GitHub).
        """
        if sociallogin.is_existing:
            return

        # Try to get a verified email from the social login
        verified_email = None
        for email_address in sociallogin.email_addresses:
            if email_address.verified:
                verified_email = email_address.email.lower().strip()
                break

        # Fallback: use the first email if any (less ideal, but better than nothing)
        if not verified_email and sociallogin.email_addresses:
            verified_email = sociallogin.email_addresses[0].email.lower().strip()

        # Final fallback: check extra_data (but safely)
        if not verified_email:
            raw_email = sociallogin.account.extra_data.get("email")
            if raw_email:
                verified_email = str(raw_email).lower().strip()

        if not verified_email:
            # No email available — can't connect, let allauth create new user
            return

        try:
            from django.contrib.auth import get_user_model

            User = get_user_model()
            try:
                existing_user = User.objects.get(email__iexact=verified_email)
                sociallogin.connect(request, existing_user)
                logger.info(
                    f"Connected {sociallogin.account.provider} account to existing user: {verified_email}"
                )
            except User.DoesNotExist:
                pass  # Normal for new signups
            except User.MultipleObjectsReturned:
                # Rare, but possible if duplicates exist
                logger.warning(f"Multiple users found with email {verified_email}")
        except Exception as e:
            logger.error(f"Error in pre_social_login: {str(e)}", exc_info=True)

    def populate_user(self, request, sociallogin, data):
        """
        Populate user with data from social provider
        Works with UUID primary key
        """
        user = super().populate_user(request, sociallogin, data)

        # Extract provider-specific data
        provider = sociallogin.account.provider
        extra_data = sociallogin.account.extra_data

        if provider == "google":
            user.avatar = extra_data.get("picture")
            user.first_name = extra_data.get("given_name", "")
            user.last_name = extra_data.get("family_name", "")

        elif provider == "facebook":
            picture_data = extra_data.get("picture", {}).get("data", {})
            user.avatar = picture_data.get("url") if picture_data else None
            user.first_name = extra_data.get("first_name", "")
            user.last_name = extra_data.get("last_name", "")

        elif provider == "github":
            user.avatar = extra_data.get("avatar_url")
            name = extra_data.get("name", "").strip()
            if name:
                parts = name.split()
                user.first_name = parts[0]
                user.last_name = " ".join(parts[1:]) if len(parts) > 1 else ""

            # Generate unique username from email if not already set
            email = data.get("email") or extra_data.get("email", "")
            if email and not user.username:
                from django.contrib.auth import get_user_model

                User = get_user_model()

                base_username = email.split("@")[0].lower()
                username = base_username
                counter = 1

                while User.objects.filter(username=username).exists():
                    username = f"{base_username}{counter}"
                    counter += 1

                user.username = username

        return user

    def save_user(self, request, sociallogin, form=None):
        """
        Save user and ensure verified status
        UUID will be auto-generated by the model
        """
        user = super().save_user(request, sociallogin, form)

        logger.info(
            f"Created new user via {sociallogin.account.provider}: {user.email} "
            f"(ID: {user.id})"
        )

        return user

    def is_auto_signup_allowed(self, request, sociallogin):
        """Allow automatic signup for social logins"""
        return True


class CustomAccountAdapter(DefaultAccountAdapter):
    """
    Custom adapter for regular (email/password) account management
    Compatible with UUID-based User model
    """

    def is_open_for_signup(self, request):
        """Control whether regular signups are allowed"""
        return True

    def send_mail(self, template_prefix, email, context):
        """
        Customize email sending — add frontend URL and stringify UUID
        """
        context["frontend_url"] = settings.FRONTEND_URL

        if "user" in context and hasattr(context["user"], "id"):
            context["user_id"] = str(context["user"].id)

        return super().send_mail(template_prefix, email, context)

    def save_user(self, request, user, form, commit=True):
        """
        Save user with proper audit trail (e.g., created_by)
        """
        user = super().save_user(request, user, form, commit=False)

        # Optional: track who created this user (admin/staff creating users)
        if hasattr(request, "user") and request.user.is_authenticated:
            user.created_by = request.user

        if commit:
            user.save()

        return user

    def get_email_confirmation_url(self, request, emailconfirmation):
        """
        Generate frontend-based email confirmation URL
        """
        return f"{settings.FRONTEND_URL}/confirm-email/{emailconfirmation.key}/"
